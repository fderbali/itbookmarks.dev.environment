#!/usr/bin/env bash
# This script was generated by bashly 0.8.1 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
itbookmarks_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks - itbookmarks development toolset\n"
    echo

  else
    printf "itbookmarks - itbookmarks development toolset\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks [command]\n"
  printf "  itbookmarks [command] --help | -h\n"
  printf "  itbookmarks --version | -v\n"
  echo
  # :command.usage_commands
  printf "Environment Commands:\n"
  echo "  build     Build all of the images or the specified one"
  echo "  check     Check the status of the environment"
  echo "  destroy   Wipe out the entire Docker environment from the system"
  echo "  down      Stop and destroy all containers"
  echo "  init      Initialize the entire Docker environment"
  echo "  logs      Display and tail the logs of all containers or the specified one"
  echo "  restart   Restart all containers or the specified one"
  echo "  ssl       Internal SSL management commands"
  echo "  start     Start the environment (all containers)"
  echo "  stop      Stop the environment (all containers)"
  echo "  update    Update the environment"
  printf "\nAPI Commands:\n"
  echo "  api       API-specific commands."
  printf "\nrim Commands:\n"
  echo "  rim       Rim client-specific commands."
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
itbookmarks_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks build - Build all of the images or the specified one\n"
    echo

  else
    printf "itbookmarks build - Build all of the images or the specified one\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks build [SERVICE]\n"
  printf "  itbookmarks build --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  SERVICE"
    printf "    Specify service to build for\n"
    echo

  fi
}

# :command.usage
itbookmarks_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks check - Check the status of the environment\n"
    echo

  else
    printf "itbookmarks check - Check the status of the environment\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks check\n"
  printf "  itbookmarks check --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_destroy_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks destroy - Wipe out the entire Docker environment from the system\n"
    echo

  else
    printf "itbookmarks destroy - Wipe out the entire Docker environment from the system\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks destroy\n"
  printf "  itbookmarks destroy --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_down_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks down - Stop and destroy all containers\n"
    echo

  else
    printf "itbookmarks down - Stop and destroy all containers\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks down [options]\n"
  printf "  itbookmarks down --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --volumes"
    printf "    Destroy the volumes as well\n"
    echo

  fi
}

# :command.usage
itbookmarks_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks init - Initialize the entire Docker environment\n"
    echo

  else
    printf "itbookmarks init - Initialize the entire Docker environment\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks init\n"
  printf "  itbookmarks init --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_logs_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks logs - Display and tail the logs of all containers or the specified one\n"
    echo

  else
    printf "itbookmarks logs - Display and tail the logs of all containers or the specified one\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks logs [CONTAINER]\n"
  printf "  itbookmarks logs --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Specify container to get the logs for\n"
    echo

  fi
}

# :command.usage
itbookmarks_restart_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks restart - Restart all containers or the specified one\n"
    echo

  else
    printf "itbookmarks restart - Restart all containers or the specified one\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks restart [CONTAINER]\n"
  printf "  itbookmarks restart --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Specify container to restart\n"
    echo

  fi
}

# :command.usage
itbookmarks_ssl_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks ssl - Internal SSL management commands\n"
    echo

  else
    printf "itbookmarks ssl - Internal SSL management commands\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks ssl [command]\n"
  printf "  itbookmarks ssl [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  install   Install the root CA inside all (default) or a list of containers"
  echo "  fix       Destroy and restart containers to regenerate and reinstall certificates"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_ssl_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks ssl install - Install the root CA inside all (default) or a list of containers\n"
    echo

  else
    printf "itbookmarks ssl install - Install the root CA inside all (default) or a list of containers\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks ssl install [CONTAINER]\n"
  printf "  itbookmarks ssl install --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Specify container to restart\n"
    echo

  fi
}

# :command.usage
itbookmarks_ssl_fix_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks ssl fix - Destroy and restart containers to regenerate and reinstall certificates\n"
    echo

  else
    printf "itbookmarks ssl fix - Destroy and restart containers to regenerate and reinstall certificates\n"
    echo

  fi

  printf "Alias: f\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks ssl fix\n"
  printf "  itbookmarks ssl fix --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks start - Start the environment (all containers)\n"
    echo

  else
    printf "itbookmarks start - Start the environment (all containers)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks start\n"
  printf "  itbookmarks start --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks stop - Stop the environment (all containers)\n"
    echo

  else
    printf "itbookmarks stop - Stop the environment (all containers)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks stop\n"
  printf "  itbookmarks stop --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks update - Update the environment\n"
    echo

  else
    printf "itbookmarks update - Update the environment\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks update [options]\n"
  printf "  itbookmarks update --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --rebuild"
    printf "    Also rebuild the images via Docker Compose\n"
    echo

    # :flag.usage
    echo "  --ssl"
    printf "    Also re-install the SSL certificates\n"
    echo

  fi
}

# :command.usage
itbookmarks_api_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks api - API-specific commands.\n"
    echo

  else
    printf "itbookmarks api - API-specific commands.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks api [command]\n"
  printf "  itbookmarks api [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  init       Run the API application's initialisation script"
  echo "  artisan    Run an artisan command on the API application"
  echo "  composer   Run a composer command on the API application"
  echo "  phpunit    Run PHPUnit on the API application"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  itbookmarks api <command> [options] [arguments]\n"
    echo

  fi
}

# :command.usage
itbookmarks_api_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks api init - Run the API application's initialisation script\n"
    echo

  else
    printf "itbookmarks api init - Run the API application's initialisation script\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks api init\n"
  printf "  itbookmarks api init --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_api_artisan_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks api artisan - Run an artisan command on the API application\n"
    echo

  else
    printf "itbookmarks api artisan - Run an artisan command on the API application\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks api artisan [ANY ARTISAN COMMAND, ARGUMENT OR FLAG...]\n"
  printf "  itbookmarks api artisan --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_api_composer_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks api composer - Run a composer command on the API application\n"
    echo

  else
    printf "itbookmarks api composer - Run a composer command on the API application\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks api composer [ANY COMPOSER COMMAND, ARGUMENT OR FLAG...]\n"
  printf "  itbookmarks api composer --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_api_phpunit_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks api phpunit - Run PHPUnit on the API application\n"
    echo

  else
    printf "itbookmarks api phpunit - Run PHPUnit on the API application\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks api phpunit [PATH]\n"
  printf "  itbookmarks api phpunit --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PATH"
    printf "    Specify the path to tests\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  itbookmarks api phpunit tests[/dir][/file]\n"
    echo

  fi
}

# :command.usage
itbookmarks_rim_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks rim - Rim client-specific commands.\n"
    echo

  else
    printf "itbookmarks rim - Rim client-specific commands.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks rim [command]\n"
  printf "  itbookmarks rim [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  init   Run the client application's initialization script"
  echo "  npm    Run a npm command on the client application"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  itbookmarks rim <command> [options] [arguments]\n"
    echo

  fi
}

# :command.usage
itbookmarks_rim_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks rim init - Run the client application's initialization script\n"
    echo

  else
    printf "itbookmarks rim init - Run the client application's initialization script\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "Usage:\n"
  printf "  itbookmarks rim init\n"
  printf "  itbookmarks rim init --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
itbookmarks_rim_npm_usage() {
  if [[ -n $long_usage ]]; then
    printf "itbookmarks rim npm - Run a npm command on the client application\n"
    echo

  else
    printf "itbookmarks rim npm - Run a npm command on the client application\n"
    echo

  fi

  printf "Usage:\n"
  printf "  itbookmarks rim npm [ANY NPM COMMAND, ARGUMENT OR FLAG...]\n"
  printf "  itbookmarks rim npm --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
#

#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# src/lib/config.sh
# ---
# Config functions
# This file is a part of Bashly standard library
#
# Usage:
# - In your script, set the CONFIG_FILE variable. For rxample:
#   CONFIG_FILE=settings.ini.
#   If it is unset, it will default to 'config.ini'.
# - Use any of the functions below to access the config file.
# ---

# Create a new config file.
# There is normally no need to use this fucntion, it is used by other
# functions as needed.
config_init() {
  CONFIG_FILE=${CONFIG_FILE:=config.ini}
  [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
}

# Get a value from the config
# Usage: result=$(config_get hello)
config_get() {
  key=$1
  regex="^$key *= *(.+)$"

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[1]}"
      break
    fi
  done < "$CONFIG_FILE"

  echo "$value"
}

# Add or update a key=value pair in the config.
# Usage: config_set key value
config_set() {
  key=$1
  shift
  value="$*"

  config_init

  regex="^($key) *= *.+$"
  output=""
  found_key=""

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[1]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Delete a key from teh config.
# Usage: config_del key
config_del() {
  key=$1

  regex="^($key) *="
  output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Show the config file
config_show() {
  config_init
  cat "$CONFIG_FILE"
}

# Return an array of the keys in the config file
# Usage:
#
#   for k in $(config_keys); do
#     echo "- $k = $(config_get "$k")";
#   done
#
config_keys() {
  regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      keys+=("$key")
    fi
  done < "$CONFIG_FILE"
  echo "${keys[@]}"
}

# Returns true if the specified key exists in the config file
# Usage:
#
#   if config_has_key "key" ; then
#     echo "key exists"
#   fi
#
config_has_key() {
  [[ $(config_get "$1") ]]
}

# src/lib/docker_compose.sh
# Build the specified service's image or all of them.
docker_compose_build () {
    docker compose build "${@:1}"
}

# Stop and destroy all containers.
#
# Options:
#  --volumes, -v   also destroy volumes
docker_compose_down () {
    docker compose down "${@:1}"
}

# (Re)Create and start the containers and volumes.
docker_compose_start () {
    docker compose up -d
}

# Restart the containers.
docker_compose_restart () {
    docker compose restart "${@:1}"
}

# src/lib/environment.sh
# Check the status of the environment
check () {
    info "Checking status of environment..."
    updated=true

    if [[ $(git status --untracked-files=no) == *"Your branch is behind"* ]]; then
        updated=false
    fi

    for repository in "$(config_get repositories)";
    do
        if [[ $(git -C "src/$repository" status --untracked-files=no) == *"Your branch is behind"* ]]; then
            updated=false
        fi
    done

    if [[ "$updated" == true ]]; then
        success "Your environment is up to date!"
    else
        call_to_action "Your environment is out of date, please do a 'boc update'"
    fi

    # Also validate host file
    validate_host_file
}

# Create .env file from .env.example.
env () {
    if [ ! -f .env ]; then
        info "Copying .env.example file to .env..."
        cp .env.example .env
    fi
}

# Display an information message.
info () {
    echo
    echo "$(tput setaf 7)-> $1 $(tput sgr 0)"
}

# Display a call to action message
call_to_action () {
    echo "$(tput setaf 3)! $1 $(tput sgr 0)"
}

# Display a success message
success () {
    echo "$(tput setaf 2)~ $1 $(tput sgr 0)"
}

# Display an error message
error () {
    echo "$(tput setaf 1)Error: $1 $(tput sgr 0)"
}

# Clone or update all repositories or the specified ones.
repositories () {
    for repository in $(config_get repositories);
    do
        if [ -d "src/$repository" ]; then
            info "Pruning and pulling repository $(config_get repositories_prefix).$repository..."
            git -C "src/$repository" prune origin
            git -C "src/$repository" pull origin || git -C "src/$repository" pull origin dev
        else
            call_to_action "Repository not initialized, cloning..."
            echo "git@github.com:fderbali/$(config_get repositories_prefix).$repository.git" "src/$repository"
            git clone "git@github.com:fderbali/$(config_get repositories_prefix).$repository.git" "src/$repository"
        fi
    done
}

# Check for running containers and stop them
stop_running_containers () {
    running_containers=$(docker container ls -f "status=running" -q)
    if [[ ${running_containers} ]]; then
        call_to_action "Containers are currently running"
        info "Stopping containers..."
        docker stop ${running_containers}
        success "Containers stopped!"
    fi
}

# src/lib/host_file.sh
# Validate if the host file contains test domain
validate_host_file () {
    if [[ "$OSTYPE" == "darwin"* || "$OSTYPE" == "linux-gnu" ]]; then
        host_file="/etc/hosts"
    else
        host_file="C:\Windows\System32\drivers\etc\hosts"
    fi

    if grep -Fq "$(config_get test_domain)" $host_file
    then
        success "Host file valid."
    else
        call_to_action "Please add the following line to your host file (${host_file}):"

        host_line="127.0.0.1  "
        for service in "$(config_get ssl_services)";
        do
            host_line="${host_line} ${service}.$(config_get test_domain)"
            echo "----------".${host_line}."----------";
        done

        echo ${host_line}
    fi
}

# src/lib/service_init.sh
# Run the specified service's initialisation script.
service_init () {
    info "Running ${1}'s initialization script..."
    docker compose run -u root --rm --entrypoint="//opt/files/init.sh" "$1"
}

# src/lib/service_laravel.sh
# Run an artisan command on the specified service.
service_laravel_artisan () {
    info "Running artisan ${@:2} on ${1}..."
    docker compose run --rm ${1} php artisan "${@:2}"
}

# Run the api's database migrations.
service_laravel_migrate () {
    service_laravel_artisan $1 "${@:2}"
}

# src/lib/service_npm.sh
# Run a npm command on the specified service.
service_npm () {
    info "Running npm ${@:2} on ${1}..."
    docker compose run --rm ${1} npm --prefix "//var/www" "${@:2}"
}

# src/lib/service_php.sh
# Run a composer command on the specified service.
service_composer () {
    info "Running composer ${@:2} on ${1}..."
    docker compose run --rm ${1} composer "${@:2}"
}

# Run PHPUnit on the specified service.
service_phpunit () {
    info "Running phpunit ${@:2} on ${1}..."
    docker compose run --rm --entrypoint="vendor/bin/phpunit" "$1" "${@:2}" -v --testdox
}

# src/lib/ssl.sh
# Generate a Certificate Authority as well as a wildcard certificate (*.$(config_get test_domain)).
ssl_generate () {
    info "Generating new self-signed certificate..."
    rm -Rf .docker/nginx/certs/$(config_get test_domain).*
    docker compose run --rm nginx sh -c "cd /etc/nginx/certs && touch openssl.cnf && cat /etc/ssl/openssl.cnf > openssl.cnf && echo \"\" >> openssl.cnf && echo \"[ SAN ]\" >> openssl.cnf && echo \"subjectAltName=DNS.1:$(config_get test_domain),DNS.2:*.$(config_get test_domain)\" >> openssl.cnf && openssl req -x509 -sha256 -nodes -newkey rsa:4096 -keyout $(config_get test_domain).key -out $(config_get test_domain).crt -days 3650 -subj \"/CN=*.$(config_get test_domain)\" -config openssl.cnf -extensions SAN && rm openssl.cnf"
}

# Install the self-signed certificate on the local machine
# (when possible), as well as in the relevant containers.
#
# Will install the certificate on all containers by default,
# or on the specified list of containers.
ssl_install () {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        info "Installing the self-signed certificate on your local machine..."
        sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain .docker/nginx/certs/$(config_get test_domain).crt
    elif [[ "$OSTYPE" == "linux-gnu" ]]; then
        info "Installing the self-signed certificate on your local machine..."
        sudo ln -s "$(pwd)/.docker/nginx/certs/$(config_get test_domain).crt" /usr/local/share/ca-certificates/$(config_get test_domain).crt
        sudo update-ca-certificates
        echo "Ensuring Chrome accepts it..."
        sudo apt-get install libnss3-tools
        certutil -D -d sql:$HOME/.pki/nssdb -n $(config_get test_domain)
        certutil -d sql:$HOME/.pki/nssdb -A -t "CT,C,C" -n $(config_get test_domain) -i /etc/ssl/certs/$(config_get test_domain).pem
    else
        call_to_action "Could not install the self-signed certificate on your local machine, please do it manually!"
    fi

    if [ $# -eq 0 ]; then
        services=($(config_get ssl_services))
    else
        services=$@
    fi

    for i in ${services[@]}
    do
        info "Adding the self-signed certificate to service $i..."
        docker compose exec ${i} update-ca-certificates
    done
}

# Check if SSL services are available through http
ssl_service_available () {
    info "Waiting for services to get available..."
    for i in $(config_get ssl_services);
        do

        count=1
        while [ $count -le 10 ]; do
            response=$(curl --write-out '%{http_code}' --silent --output /dev/null --connect-timeout 5 https://$i.$(config_get test_domain))
            if [[ $response == "200" || $response == "404" ]]; then
                success "$i is available at https://$i.$(config_get test_domain)"
                break
            fi

            if [[ $response == "000" ]]; then
                error "$i is unavailable: either the SSL certificate is not installed locally or nginx is not available"
                break
            fi

            sleep 5
            ((count++))
        done

        if [ "$count" -ge 10 ]; then
            error "$i is unavailable: verification exceeded 10 attempt"
        fi
    done
}

# :command.command_functions
# :command.function
itbookmarks_build_command() {
  # src/build_command.sh
  # Build the specified service's image or all of them.
  # see lib/build.sh
  if [[ ${args[service]} ]]; then
      info "Building '${args[service]}' service..."
      docker_compose_build "${args[service]}"
  else
      info "Building environment..."
      docker_compose_build
  fi
}

# :command.function
itbookmarks_check_command() {
  # src/check_command.sh
  # Check the status of the environment
  check
}

# :command.function
itbookmarks_destroy_command() {
  # src/destroy_command.sh
  # Destroy docker containers, volumes and images.
  echo
  read -p "This will remove containers, volumes as well as images. Are you sure? [y/N]: " -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then exit 1; fi
  docker compose down -v --rmi all
}

# :command.function
itbookmarks_down_command() {
  # src/down_command.sh
  # Stop and destroy all containers.
  # see lib/down.sh
  info "Stopping the local environment and removing all containers..."

  if [[ ${args[--volumes]} ]]; then
      docker_compose_down -v
  else
      docker_compose_down
  fi
}

# :command.function
itbookmarks_init_command() {
  # src/init_command.sh
  # Initialize the environment
  # see lib/
  # Make sure all other containers are closed
  stop_running_containers

  # Initialize
  info "Initializing the local environment..."
  env \
      ; validate_host_file \
      ; repositories \
      ; docker_compose_down -v \
      ; docker_compose_build \
      ; service_init api \
      ; service_init rim

  if [ ! -f .docker/nginx/certs/itbookmarks.test.crt ]; then
      ssl_generate
  else
      success "Using existing self-signed certificate. Run 'itbookmarks ssl generate' and 'itbookmarks ssl install' if you need a new one."
  fi

  docker_compose_start \
      ; ssl_install \
      ; ssl_service_available
}

# :command.function
itbookmarks_logs_command() {
  # src/logs_command.sh
  # Display and tail the logs.
  if [[ ${args[service]} ]]; then
      docker compose logs "${args[service]}"
  else
      docker compose logs
  fi
}

# :command.function
itbookmarks_restart_command() {
  # src/restart_command.sh
  # Restart all containers or one container
  docker_compose_restart "${@:1}" \
      ; check \
      ; ssl_service_available
}

# :command.function
itbookmarks_ssl_install_command() {
  # src/ssl_install_command.sh
  # Install SSL certificates
  # see lib/ssl_install.sh
  ssl_install
}

# :command.function
itbookmarks_ssl_fix_command() {
  # src/ssl_fix_command.sh
  # Fix SSL container issues.
  info "Fixing the SSL..."
  docker compose rm -f -s -v nationalmap \
      ; docker compose rm -f -s -v nginx \
      ; docker compose up -d \
      ; ssl_generate \
      ; ssl_install
}

# :command.function
itbookmarks_start_command() {
  # src/start_command.sh
  # (Re)Create and start the containers and volumes.

  # Make sure all other containers are closed
  stop_running_containers

  # Start the environment
  info "Starting the local environment..."
  docker_compose_start \
      ; check \
      ; ssl_service_available
}

# :command.function
itbookmarks_stop_command() {
  # src/stop_command.sh
  # Stop all containers.
  info "Stopping the local environment..."
  docker compose stop
}

# :command.function
itbookmarks_update_command() {
  # src/update_command.sh
  # Update the local environment:
  #  * pull the environment's latest changes;
  #  * clone or update each application's repository;
  #  * (re)build the images;
  #  * run the database migrations;
  #  * install the dependencies;
  #  * (re)install the ssl certificate.
  info "Updating the local environment..."
  git pull && repositories

  # Rebuild the environment
  stop_running_containers
  if [[ ${args[--rebuild]} ]]; then
      info "Rebuilding via docker compose..."

      docker_compose_build
  fi

  # Update services
  # ...

  # Restart the environment
  info "Restarting the local environment..."
  docker_compose_start

  # Re-install the SSL
  if [[ ${args[--ssl]} ]]; then
      ssl_install
  fi

  check
  ssl_service_available
}

# :command.function
itbookmarks_api_init_command() {
  # src/api_init_command.sh
  # Initialize API
  service_init api
}

# :command.function
itbookmarks_api_artisan_command() {
  # src/api_artisan_command.sh
  # Laravel artisan command on api service
  service_laravel_artisan api ${other_args[*]}
}

# :command.function
itbookmarks_api_composer_command() {
  # src/api_composer_command.sh
  # Laravel artisan command on api service
  service_composer api ${other_args[*]}
}

# :command.function
itbookmarks_api_phpunit_command() {
  # src/api_phpunit_command.sh
  # Laravel artisan command on api service
  service_phpunit api ${args[path]}
}

# :command.function
itbookmarks_rim_init_command() {
  # src/rim_init_command.sh
  # Initialize admin
  service_init rim
}

# :command.function
itbookmarks_rim_npm_command() {
  # src/rim_npm_command.sh
  # NPM command on admin service
  service_npm rim ${other_args[*]}
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    itbookmarks_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  if ! [[ -x "$(command -v curl)" ]]; then
    printf "missing dependency: curl\n"
    exit 1
  fi
  if ! [[ -x "$(command -v docker)" ]]; then
    printf "missing dependency: docker\n"
    exit 1
  fi
  if ! [[ -x "$(command -v git)" ]]; then
    printf "missing dependency: git\n"
    exit 1
  fi
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  build | b )
    action="build"
    shift
    itbookmarks_build_parse_requirements "$@"
    shift $#
    ;;

  check | c )
    action="check"
    shift
    itbookmarks_check_parse_requirements "$@"
    shift $#
    ;;

  destroy )
    action="destroy"
    shift
    itbookmarks_destroy_parse_requirements "$@"
    shift $#
    ;;

  down | d )
    action="down"
    shift
    itbookmarks_down_parse_requirements "$@"
    shift $#
    ;;

  init | i )
    action="init"
    shift
    itbookmarks_init_parse_requirements "$@"
    shift $#
    ;;

  logs | l )
    action="logs"
    shift
    itbookmarks_logs_parse_requirements "$@"
    shift $#
    ;;

  restart | r )
    action="restart"
    shift
    itbookmarks_restart_parse_requirements "$@"
    shift $#
    ;;

  ssl )
    action="ssl"
    shift
    itbookmarks_ssl_parse_requirements "$@"
    shift $#
    ;;

  start )
    action="start"
    shift
    itbookmarks_start_parse_requirements "$@"
    shift $#
    ;;

  stop )
    action="stop"
    shift
    itbookmarks_stop_parse_requirements "$@"
    shift $#
    ;;

  update )
    action="update"
    shift
    itbookmarks_update_parse_requirements "$@"
    shift $#
    ;;

  api )
    action="api"
    shift
    itbookmarks_api_parse_requirements "$@"
    shift $#
    ;;

  rim )
    action="rim"
    shift
    itbookmarks_rim_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    itbookmarks_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_build_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_build_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="build"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[service]+x} ]]; then
        # :argument.validations
        args[service]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_check_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_check_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="check"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_destroy_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_destroy_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="destroy"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_down_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_down_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="down"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --volumes )
      # :flag.conflicts
      # :flag.case_no_arg
      args[--volumes]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_init_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_init_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="init"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_logs_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_logs_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="logs"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_restart_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_restart_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="restart"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_ssl_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_ssl_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  install | i )
    action="install"
    shift
    itbookmarks_ssl_install_parse_requirements "$@"
    shift $#
    ;;

  fix | f )
    action="fix"
    shift
    itbookmarks_ssl_fix_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    itbookmarks_ssl_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_ssl_install_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_ssl_install_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="ssl install"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_ssl_fix_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_ssl_fix_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="ssl fix"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_start_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_start_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="start"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_stop_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_stop_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="stop"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_update_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_update_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="update"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --rebuild )
      # :flag.conflicts
      # :flag.case_no_arg
      args[--rebuild]=1
      shift
      ;;

    # :flag.case
    --ssl )
      # :flag.conflicts
      # :flag.case_no_arg
      args[--ssl]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_api_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_api_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  init | i )
    action="init"
    shift
    itbookmarks_api_init_parse_requirements "$@"
    shift $#
    ;;

  artisan )
    action="artisan"
    shift
    itbookmarks_api_artisan_parse_requirements "$@"
    shift $#
    ;;

  composer )
    action="composer"
    shift
    itbookmarks_api_composer_parse_requirements "$@"
    shift $#
    ;;

  phpunit )
    action="phpunit"
    shift
    itbookmarks_api_phpunit_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    itbookmarks_api_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_api_init_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_api_init_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="api init"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_api_artisan_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_api_artisan_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="api artisan"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      other_args+=("$1")
      shift
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_api_composer_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_api_composer_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="api composer"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      other_args+=("$1")
      shift
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_api_phpunit_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_api_phpunit_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="api phpunit"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[path]+x} ]]; then
        # :argument.validations
        args[path]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_rim_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_rim_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  init | i )
    action="init"
    shift
    itbookmarks_rim_init_parse_requirements "$@"
    shift $#
    ;;

  npm )
    action="npm"
    shift
    itbookmarks_rim_npm_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    itbookmarks_rim_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_rim_init_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_rim_init_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="rim init"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
itbookmarks_rim_npm_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    itbookmarks_rim_npm_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="rim npm"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      other_args+=("$1")
      shift
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_catch_all
      other_args+=("$1")
      shift
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="1.1.3"
  long_usage=''
  set -e

  # src/initialize.sh
  # Initialize bashly
  CONFIG_FILE=bashly.ini
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "build" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_build_usage
    else
      itbookmarks_build_command
    fi

  elif [[ $action == "check" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_check_usage
    else
      itbookmarks_check_command
    fi

  elif [[ $action == "destroy" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_destroy_usage
    else
      itbookmarks_destroy_command
    fi

  elif [[ $action == "down" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_down_usage
    else
      itbookmarks_down_command
    fi

  elif [[ $action == "init" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_init_usage
    else
      itbookmarks_init_command
    fi

  elif [[ $action == "logs" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_logs_usage
    else
      itbookmarks_logs_command
    fi

  elif [[ $action == "restart" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_restart_usage
    else
      itbookmarks_restart_command
    fi

  elif [[ $action == "ssl" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_ssl_usage
    else
      itbookmarks_ssl_command
    fi

  elif [[ $action == "ssl install" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_ssl_install_usage
    else
      itbookmarks_ssl_install_command
    fi

  elif [[ $action == "ssl fix" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_ssl_fix_usage
    else
      itbookmarks_ssl_fix_command
    fi

  elif [[ $action == "start" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_start_usage
    else
      itbookmarks_start_command
    fi

  elif [[ $action == "stop" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_stop_usage
    else
      itbookmarks_stop_command
    fi

  elif [[ $action == "update" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_update_usage
    else
      itbookmarks_update_command
    fi

  elif [[ $action == "api" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_api_usage
    else
      itbookmarks_api_command
    fi

  elif [[ $action == "api init" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_api_init_usage
    else
      itbookmarks_api_init_command
    fi

  elif [[ $action == "api artisan" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_api_artisan_usage
    else
      itbookmarks_api_artisan_command
    fi

  elif [[ $action == "api composer" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_api_composer_usage
    else
      itbookmarks_api_composer_command
    fi

  elif [[ $action == "api phpunit" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_api_phpunit_usage
    else
      itbookmarks_api_phpunit_command
    fi

  elif [[ $action == "rim" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_rim_usage
    else
      itbookmarks_rim_command
    fi

  elif [[ $action == "rim init" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_rim_init_usage
    else
      itbookmarks_rim_init_command
    fi

  elif [[ $action == "rim npm" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      itbookmarks_rim_npm_usage
    else
      itbookmarks_rim_npm_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"